# KVSの基本

## KVSとは何をするためのもの？

Key-Value形式のデータを扱うデータストア。
Keyを指定すると、対応するValueが呼び出される仕組み。

## KVSが生まれた背景

Googleの代表的なKVSであるBigtableは大規模にスケール可能な分散ストレージシステムとして
開発された。

検索やGoogle Earth、Financeなど数のサービスにまたがって、様々な種類のデータ（画像、文字列 e.t.c）を
ペタバイトオーダーで管理している。

大規模なデータサイズに加え、非常に低いレイテンシ（リアルタイムストリーミング）を可能にしている。

ポイント：データの水平スケールのしやすさと読み書きのレイテンシ。ハイパフォーマンス・拡張性・可用性。

## RDSとKVSの比較

- KVSの方が分散化のコストが小さい。KVSはデータ構造が単純なため、分散化しやすい。
- KVSの方が負荷分散のコストが小さい。RDSを負荷分散するためには、DBのレプリケーションやシャード分割によるクラスタ構築やキャッシュの導入が必要になる。
結果的にコストが高くなりやすい。
- KVSの方が高可用性である。なぜだ？言語化できない。レプリカの作成が用意だから？クラスタ化するのが簡単だから？。
- KVSはRDSほどデータの堅牢性・一貫性を保つことができない。
- KVSはRDSほどトランザクションを厳密に管理できない。厳密に管理しようとすると、書き込みのパフォーマンスが落ちる。
- KVSは複雑な検索はできない。基本的にKeyをもとに探すだけ。

## 分散システムのトレードオフ

CAP定理：Availability・分断耐性・一貫性の3つを同時に満たすことはできない。

ノード間のデータ複製において、同時に次の3つの保証を提供することはできない。
分散システムのトレードオフを判断するために利用している。

### 一貫性 (Consistency)
すべてのデータ読み込みにおいて、最新の書き込みデータもしくはエラーのどちらか
を受け取る。

e.g. データの更新中に読み取りが発生すると、最新のデータを返すことができない。

### 可用性 (Availability)
ノード障害により生存ノードの機能性は損なわれない。つまり、ダウンしていない
ノードが常に応答を返す。単一障害点が存在しないことが必要。

ノードがクラスタ化されている。

### 分断耐性 (Partition-tolerance)
システムは任意の通信障害などによるメッセージ損失に対し、継続して動作を行う。
通信可能なサーバーが複数のグループに分断されるケース（ネットワーク分断）を指
し、1つのハブに全てのサーバーがつながっている場合は、これは発生しない。
ただし、そのようなネットワーク設計は単一障害点をもつことになり、可用性が成
立しない。RDBではそもそもデータベースを分割しないので、このような障害とは無
縁である。

分断とは分散システム内の通信障害のこと。2つのノード間の接続が失われたか一時的に遅延している状態。

## CAP定理の解釈見直し

CAP定理の提唱者自身が「現代にそのままCAP定理をそのまま適用するのは危険」とコメント。

- インターネット上で提供する広域サービスにおいて、複数サーバーを用いた負荷分散は必須であることから分断耐性は選択せざるを得ない。
- ネットワーク上で分断が発生した場合に、一貫性を優先させるか、可用性を優先させるかの選択になる。
- 一貫性・可用性にも度合いがあり(0 or 1ではない)、システムがモードを切り替えながら稼働するケースもある。

## どうやって一貫性を担保する？

更新の際にデータをロックすることで一貫性を担保できる。
しかし、可用性とのトレードオフとなるため要件次第で決まる。

強整合性の場合、データの更新の際にデータベースをロックすることによってデータの
一貫性を担保するが、ロックされる期間が長いほどその間のデータベースアクセスがブロック
されるため可用性を犠牲にすることになる。

結果整合性はデータの更新でデータベースがロックされることはないため、可用性
とスケーラビリティを維持することができる。その代わりノード間でのデータの一貫性
はデータ複製にかかる時間に依存するため、必ずしも担保されない。

## DynamoDBの整合性モデル

### 結果整合性モデル




# KVSをデザインしよう

## KVSの機能要件は？

## KVSの非機能要件は？

# 分散KVSをデザインしよう
